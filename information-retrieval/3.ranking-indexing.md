
- [Table of Content](#table-of-content)
  - [Abstract Model of Ranking](#abstract-model-of-ranking)
    - [Document Score](#document-score)
    - [Feature Function](#feature-function)
      - [Topical Feature](#topical-feature)
      - [Quality Feature](#quality-feature)
  - [Data Structures for Web Page](#data-structures-for-web-page)
    - [Inverted Index](#inverted-index)
      - [What should not be in the inverted list](#what-should-not-be-in-the-inverted-list)
    - [Web Graph](#web-graph)
    - [Forward Index](#forward-index)
    - [Page Attribute File](#page-attribute-file)
  - [Constructing Index](#constructing-index)
    - [Simple Index](#simple-index)
    - [Two-Pass Index](#two-pass-index)
    - [One-pass index with merging](#one-pass-index-with-merging)
    - [Distributed Indexing (Map-Reduce)](#distributed-indexing-map-reduce)
    - [Update an Index](#update-an-index)
      - [No Merge](#no-merge)
      - [Incremental Update](#incremental-update)


# Table of Content
## Abstract Model of Ranking
### Document Score
  - calculated by sum of multiplications of document feature functions and query feature functions output 
  - $R(Q,D) = \sum_{i}g_i(Q)f_{i}(D)$
  - in practice, the query features are mostly zero (time complexity)

### Feature Function
  - a mathematical expression that generates numbers from document text (TFIDF???)
  - includes document features and query features
  - features could be **topical/quality**


#### Topical Feature
Estimate the degree to which the document/query is about a particular subject 
  - how do we decide these topical features ??? (phrases??? N-grams????)

#### Quality Feature
  - examples such as links to these documents, number of days since it was last updated
  - for query, it would be whether these qualities is relevant to given query nature (query about weather requires that the document be up-to-date)

## Data Structures for Web Page


### Inverted Index
Word -> Documents 
  - Dictionary using B+ tree, hash table
  - each entry (inverted list) contains 
    - Number of pages containing the term
    - Pointer to the start of the inverted 
    - other meta-data about the term
  - Typical Entry
    - Document Id
    - Frequencies
    - Positions
    - Weights
#### What should not be in the inverted list 
  - something is not describing the pair of word and document, such as: the number of documents containing the term (should go to vocabulary)
  - document length (page attribute file)


### Web Graph
  - HTML Pages -> HTML Parsers -> Web graph -> Content and Link analysis (link quality, link spam, duplicate detection, mirror site detection) -> web repository

### Forward Index
anchor text (web graph) + html page () -> text processor (tokenizer, phrase extractor, entity extractor) -> forward index
  - forward index: document -> words

### Page Attribute File
forward index (page content) + web graph (attrib) -> classifiers and feature extractors (spam classifier, adult classifier, text quality estimator ...) -> page attribute file


## Constructing Index

### Simple Index
Loop for each document D -> get all unique tokens from D -> append document Index to HashTable
  - In memory
    - Two-pass index
    - One-pass index with merging
  - Single-threaded
    - distributed index

### Two-Pass Index
  1. collect term statistics
  2. create a template of the index (word -> reserved space based on statistics) on the disk (slow?????)
  3. fill in the index template 

### One-pass index with merging 
  1.  build index A until it is full on RAM, flash it
  2.  build index B until it is full on RAM, flash it and merge with index (merge is done on disk？？？) 

### Distributed Indexing (Map-Reduce)

  -  Map: each mapper transform input to a list of key-value
  -  Reduce: each reducer take care of certain keys and aggregate them together
  -  All mapper and reducer can be parallelized (multi-threading)


### Update an Index
keep track of new documents

#### No Merge
- merge different index at query time
- low index maintainance cost
- high query processing cost (merge at query time)

#### Incremental Update
    - keep free buffer space
    - concurrent access of index (read/write)
    - run out of free buffer space


#### Immediate merge (in-memory)
    - merge delta index with old index to new index
    - always a single index
    - read/write of an entire index when updating